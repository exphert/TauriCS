// Auto-generated by make-native.mjs

using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using Globals;

namespace Sample;

/// <summary>
/// Defines the data structure for standard and external call responses.
/// </summary>
public class StandardResponse {
    public object? ReceivedData { get; set; }
    public string? MessageFromGlobals { get; set; }
    public string? ResponseType { get; set; }
    public string? ExternalLibraryResult { get; set; }
}

/// <summary>
/// Informs the .NET source generator how to serialize StandardResponse
/// without using reflection, making it safe for Native AOT.
/// </summary>
[JsonSerializable(typeof(StandardResponse))]
public partial class NativeJsonContext : JsonSerializerContext { }

/// <summary>
/// Main entry point class for the native library. Contains all exported functions.
/// </summary>
public static class NativeEntry
{
    // Define the list of executables that are allowed to host this library.
    // In dev mode, the process is your app name. In production, it's also your app name.
    private static readonly string[] ALLOWED_PROCESSES = { "taurics.exe" };

    /// <summary>
    /// Defines the signature of the progress callback function that Rust will provide.
    /// </summary>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    delegate void ProgressCallback(IntPtr message);

    // --- Core Exported Functions ---

    [UnmanagedCallersOnly(EntryPoint = "get_native_name")]
    public static IntPtr GetNativeName()
    {
        return Marshal.StringToCoTaskMemUTF8("sample");
    }

    [UnmanagedCallersOnly(EntryPoint = "free_string")]
    public static void FreeString(IntPtr stringPtr)
    {
        Marshal.FreeCoTaskMem(stringPtr);
    }

    // --- Mode 1: Standard Request-Response ---
    [UnmanagedCallersOnly(EntryPoint = "execute")]
    public static IntPtr Execute(IntPtr jsonDataPtr)
    {
        // ** SECURITY CHECK **
        var (isVerified, processName) = Security.VerifyCurrentProcess(ALLOWED_PROCESSES);
        if (!isVerified)
        {
            string errorMsg = $"Security check failed: Unauthorized host process '{processName}'.";
            return Marshal.StringToCoTaskMemUTF8("{\"Error\":\"" + JsonEncodedText.Encode(errorMsg) + "\"}");
        }

        try
        {
            var inputJson = Marshal.PtrToStringUTF8(jsonDataPtr)!;
            string sharedMessage = Shared.GetGlobalMessage();

            var outputObject = new StandardResponse {
                ReceivedData = inputJson,
                MessageFromGlobals = sharedMessage,
                ResponseType = "Single Request-Response"
            };

            var outputJson = JsonSerializer.Serialize(outputObject, NativeJsonContext.Default.StandardResponse);
            return Marshal.StringToCoTaskMemUTF8(outputJson);
        }
        catch (Exception ex)
        {
            var errorJson = "{\"Error\":\"" + JsonEncodedText.Encode(ex.Message) + "\"}";
            return Marshal.StringToCoTaskMemUTF8(errorJson);
        }
    }

    // --- Mode 2: Streaming ---
    [UnmanagedCallersOnly(EntryPoint = "execute_streaming")]
    public static void ExecuteStreaming(IntPtr jsonDataPtr, IntPtr progressCallbackPtr)
    {
        var progressCallback = Marshal.GetDelegateForFunctionPointer<ProgressCallback>(progressCallbackPtr);

        // ** SECURITY CHECK **
        var (isVerified, processName) = Security.VerifyCurrentProcess(ALLOWED_PROCESSES);
        if (!isVerified)
        {
            progressCallback(Marshal.StringToCoTaskMemUTF8($"Error: Security check failed: Unauthorized host process '{processName}'."));
            progressCallback(Marshal.StringToCoTaskMemUTF8("__STREAM_END__"));
            return;
        }

        try
        {
            progressCallback(Marshal.StringToCoTaskMemUTF8("Streaming task started...\n"));
            for (int i = 1; i <= 3; i++)
            {
                Thread.Sleep(500);
                progressCallback(Marshal.StringToCoTaskMemUTF8($"Streaming step {i}/3...\n"));
            }
            progressCallback(Marshal.StringToCoTaskMemUTF8("Streaming task complete!\n"));
        }
        catch (Exception ex) { progressCallback(Marshal.StringToCoTaskMemUTF8($"Error: {ex.Message}")); }
        finally { progressCallback(Marshal.StringToCoTaskMemUTF8("__STREAM_END__")); }
    }

    // --- Mode 3: External DLL Call ---
    [UnmanagedCallersOnly(EntryPoint = "execute_external")]
    public static IntPtr ExecuteExternal(IntPtr jsonDataPtr)
    {
        // ** SECURITY CHECK **
        var (isVerified, processName) = Security.VerifyCurrentProcess(ALLOWED_PROCESSES);
        if (!isVerified)
        {
            string errorMsg = $"Security check failed: Unauthorized host process '{processName}'.";
            return Marshal.StringToCoTaskMemUTF8("{\"Error\":\"" + JsonEncodedText.Encode(errorMsg) + "\"}");
        }

        try
        {
            var inputJson = Marshal.PtrToStringUTF8(jsonDataPtr)!;
            Random rnd = new Random();

            var (first, second) = (rnd.Next(1, 100), rnd.Next(1, 100));
            var calculator = NativeLoader.LoadFunction<NativeLoader.IntCalculationFunc>("ExternalUtility.dll", "perform_calculation");
            int calcResult = calculator(first, second);
            string externalResult = $"Calculation from external DLL: {first} + {second} = {calcResult}";

            var outputObject = new StandardResponse {
                ReceivedData = inputJson,
                ResponseType = "External DLL Call",
                ExternalLibraryResult = externalResult
            };

            var outputJson = JsonSerializer.Serialize(outputObject, NativeJsonContext.Default.StandardResponse);
            return Marshal.StringToCoTaskMemUTF8(outputJson);
        }
        catch (Exception ex)
        {
            var errorJson = "{\"Error\":\"" + JsonEncodedText.Encode(ex.Message) + "\"}";
            return Marshal.StringToCoTaskMemUTF8(errorJson);
        }
    }
}
