/**
 * @file This script automates the creation of a new, secure C# Native AOT library.
 * It scaffolds a complete C# project, configures it for Native AOT, adds a .gitignore,
 * and generates a boilerplate C# file with security checks and three distinct communication modes.
 *
 * Usage: npm run cs:make <LibraryName>
 */

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

// --- 1. Argument Parsing & Validation ---

// Get the desired library name from the command-line arguments.
const nativeName = process.argv[2];

// If no name is provided, show an error and exit.
if (!nativeName) {
  console.error('❌ Error: Please provide a native library name.');
  console.log('Usage: npm run cs:make <LibName>');
  process.exit(1);
}

// Ensure the library name follows the C# PascalCase convention to prevent issues.
if (!/^[A-Z][A-Za-z0-9]*$/.test(nativeName)) {
    console.error('❌ Error: Library name must be in PascalCase (e.g., MyNewLib).');
    process.exit(1);
}

// --- 2. Path and Directory Setup ---

// Define the target directory for the new C# library project.
const nativeDir = path.join('src-csharp', 'Native', nativeName);
// Define the relative path to the shared 'Globals' project, which is a dependency.
const globalsPath = path.join('..', '..', 'Globals', 'Globals.csproj');

console.log(`\n✨ Creating new Secure Tri-Mode Native AOT C# library: ${nativeName}`);

// Prevent overwriting an existing library.
if (fs.existsSync(nativeDir)) {
    console.error(`❌ Error: Library '${nativeName}' already exists at ${nativeDir}`);
    process.exit(1);
}
// Create the new directory.
fs.mkdirSync(nativeDir, { recursive: true });

// --- 3. Project Scaffolding and Code Generation ---

try {
    // Step A: Create a standard .NET class library project.
    console.log('   Creating .NET class library project...');
    execSync(`dotnet new classlib -o "${nativeDir}"`);

    // Step B: Add a reference to the 'Globals' project.
    console.log('   Adding reference to Globals project...');
    execSync(`dotnet add "${nativeDir}" reference "${path.join(nativeDir, globalsPath)}"`);

    // Step C: Modify the .csproj file to enable Native AOT compilation.
    console.log('   Configuring project for Native AOT...');
    const csprojPath = path.join(nativeDir, `${nativeName}.csproj`);
    let csprojContent = fs.readFileSync(csprojPath, 'utf8');
    const propertyGroup = `
  <PropertyGroup>
    <PublishAot>true</PublishAot>
    <OutputType>Library</OutputType>
  </PropertyGroup>
`;
    csprojContent = csprojContent.replace('</Project>', `${propertyGroup}</Project>`);
    fs.writeFileSync(csprojPath, csprojContent);

    // Step D: Remove the default 'Class1.cs' file.
    fs.unlinkSync(path.join(nativeDir, 'Class1.cs'));

    // Step E: Create a .gitignore file to exclude build artifacts from source control.
    console.log('   Creating .gitignore file...');
    const gitignoreContent = `# .NET Core build artifacts\nbin/\nobj/\n`;
    fs.writeFileSync(path.join(nativeDir, '.gitignore'), gitignoreContent);

    // Step F: Generate the C# source code from a template string.
    const template = `// Auto-generated by make-native.mjs

using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using Globals;

namespace ${nativeName};

/// <summary>
/// Defines the data structure for standard and external call responses.
/// </summary>
public class StandardResponse {
    public object? ReceivedData { get; set; }
    public string? MessageFromGlobals { get; set; }
    public string? ResponseType { get; set; }
    public string? ExternalLibraryResult { get; set; }
}

/// <summary>
/// Informs the .NET source generator how to serialize StandardResponse
/// without using reflection, making it safe for Native AOT.
/// </summary>
[JsonSerializable(typeof(StandardResponse))]
public partial class NativeJsonContext : JsonSerializerContext { }

/// <summary>
/// Main entry point class for the native library. Contains all exported functions.
/// </summary>
public static class NativeEntry
{
    // Define the list of executables that are allowed to host this library.
    // In dev mode, the process is your app name. In production, it's also your app name.
    private static readonly string[] ALLOWED_PROCESSES = { "taurics.exe" };

    /// <summary>
    /// Defines the signature of the progress callback function that Rust will provide.
    /// </summary>
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    delegate void ProgressCallback(IntPtr message);

    // --- Core Exported Functions ---

    [UnmanagedCallersOnly(EntryPoint = "get_native_name")]
    public static IntPtr GetNativeName()
    {
        return Marshal.StringToCoTaskMemUTF8("${nativeName.toLowerCase()}");
    }

    [UnmanagedCallersOnly(EntryPoint = "free_string")]
    public static void FreeString(IntPtr stringPtr)
    {
        Marshal.FreeCoTaskMem(stringPtr);
    }

    // --- Mode 1: Standard Request-Response ---
    [UnmanagedCallersOnly(EntryPoint = "execute")]
    public static IntPtr Execute(IntPtr jsonDataPtr)
    {
        // ** SECURITY CHECK **
        var (isVerified, processName) = Security.VerifyCurrentProcess(ALLOWED_PROCESSES);
        if (!isVerified)
        {
            string errorMsg = $"Security check failed: Unauthorized host process '{processName}'.";
            return Marshal.StringToCoTaskMemUTF8("{\\"Error\\":\\"" + JsonEncodedText.Encode(errorMsg) + "\\"}");
        }

        try
        {
            var inputJson = Marshal.PtrToStringUTF8(jsonDataPtr)!;
            string sharedMessage = Shared.GetGlobalMessage();

            var outputObject = new StandardResponse {
                ReceivedData = inputJson,
                MessageFromGlobals = sharedMessage,
                ResponseType = "Single Request-Response"
            };

            var outputJson = JsonSerializer.Serialize(outputObject, NativeJsonContext.Default.StandardResponse);
            return Marshal.StringToCoTaskMemUTF8(outputJson);
        }
        catch (Exception ex)
        {
            var errorJson = "{\\"Error\\":\\"" + JsonEncodedText.Encode(ex.Message) + "\\"}";
            return Marshal.StringToCoTaskMemUTF8(errorJson);
        }
    }

    // --- Mode 2: Streaming ---
    [UnmanagedCallersOnly(EntryPoint = "execute_streaming")]
    public static void ExecuteStreaming(IntPtr jsonDataPtr, IntPtr progressCallbackPtr)
    {
        var progressCallback = Marshal.GetDelegateForFunctionPointer<ProgressCallback>(progressCallbackPtr);

        // ** SECURITY CHECK **
        var (isVerified, processName) = Security.VerifyCurrentProcess(ALLOWED_PROCESSES);
        if (!isVerified)
        {
            progressCallback(Marshal.StringToCoTaskMemUTF8($"Error: Security check failed: Unauthorized host process '{processName}'."));
            progressCallback(Marshal.StringToCoTaskMemUTF8("__STREAM_END__"));
            return;
        }

        try
        {
            progressCallback(Marshal.StringToCoTaskMemUTF8("Streaming task started...\\n"));
            for (int i = 1; i <= 3; i++)
            {
                Thread.Sleep(500);
                progressCallback(Marshal.StringToCoTaskMemUTF8($"Streaming step {i}/3...\\n"));
            }
            progressCallback(Marshal.StringToCoTaskMemUTF8("Streaming task complete!\\n"));
        }
        catch (Exception ex) { progressCallback(Marshal.StringToCoTaskMemUTF8($"Error: {ex.Message}")); }
        finally { progressCallback(Marshal.StringToCoTaskMemUTF8("__STREAM_END__")); }
    }

    // --- Mode 3: External DLL Call ---
    [UnmanagedCallersOnly(EntryPoint = "execute_external")]
    public static IntPtr ExecuteExternal(IntPtr jsonDataPtr)
    {
        // ** SECURITY CHECK **
        var (isVerified, processName) = Security.VerifyCurrentProcess(ALLOWED_PROCESSES);
        if (!isVerified)
        {
            string errorMsg = $"Security check failed: Unauthorized host process '{processName}'.";
            return Marshal.StringToCoTaskMemUTF8("{\\"Error\\":\\"" + JsonEncodedText.Encode(errorMsg) + "\\"}");
        }

        try
        {
            var inputJson = Marshal.PtrToStringUTF8(jsonDataPtr)!;
            Random rnd = new Random();

            var (first, second) = (rnd.Next(1, 100), rnd.Next(1, 100));
            var calculator = NativeLoader.LoadFunction<NativeLoader.IntCalculationFunc>("ExternalUtility.dll", "perform_calculation");
            int calcResult = calculator(first, second);
            string externalResult = $"Calculation from external DLL: {first} + {second} = {calcResult}";

            var outputObject = new StandardResponse {
                ReceivedData = inputJson,
                ResponseType = "External DLL Call",
                ExternalLibraryResult = externalResult
            };

            var outputJson = JsonSerializer.Serialize(outputObject, NativeJsonContext.Default.StandardResponse);
            return Marshal.StringToCoTaskMemUTF8(outputJson);
        }
        catch (Exception ex)
        {
            var errorJson = "{\\"Error\\":\\"" + JsonEncodedText.Encode(ex.Message) + "\\"}";
            return Marshal.StringToCoTaskMemUTF8(errorJson);
        }
    }
}
`;
    const newFilePath = path.join(nativeDir, `NativeEntry.cs`);
    fs.writeFileSync(newFilePath, template);

    console.log(`\n✅ Success! New secure tri-mode library '${nativeName}' created.`);

} catch (error) {
    console.error('\n❌ An error occurred:', error.message);
    // If any step fails, clean up the created directory to ensure a clean state.
    fs.rmSync(nativeDir, { recursive: true, force: true });
}
